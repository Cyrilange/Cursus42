===== ./readme.md =====
## **This project has been created as part of the 42 curriculum by csalamit**
<br>

# Inception




## **Description**

The Inception project aims to introduce the fundamentals of system administration and DevOps practices using Docker and Docker Compose.  
The goal of this project is to build a secure, modular, and reproducible infrastructure composed of multiple services running in isolated containers.

The project focuses on deploying a WordPress website served by NGINX, using MariaDB as the database, all running inside Docker containers and communicating through a dedicated Docker network. Special attention is given to security, data persistence, and proper service separation.

what is **Docker** ?

It is a container engine that uses the Linux Kernel features to create containers on top of an operating system created on 20 mars 2013 by Salomon Hykes

Docker is used to set up and deploy applications using containers.

The basic structure of Docker relies on images and containers

What is **container** ? 

A way to package application with all the necessary dependancies and configuration

A container is an isolated system that holds everything required to run a specific application

What is **image** ?

A Docker image is basically a snapshot of a filesystem and configuration that defines what a container will look like when it runs.

exemple of a **Dockerfile** , an image nginx (for inception we will use bullseye)

	FROM		alpine:3.12

						RUN			apk update && apk upgrade && apk add	\
													openssl			\
													nginx			\
													curl			\
													vim				\
													sudo

						RUN			rm -f /etc/nginx/nginx.conf

						COPY		./config/nginx.conf /etc/nginx/nginx.conf
						COPY		scripts/setup_nginx.sh /setup_nginx.sh

						RUN			chmod -R +x /setup_nginx.sh

						EXPOSE		443

						ENTRYPOINT	["sh", "setup_nginx.sh"]






FROM
Specifies the base OS for the container.

RUN
Executes commands in the container (like SSH + bash).

COPY
Copies files from your project into the container.

EXPOSE
Declares the network ports the container listens on.

ENTRYPOINT / CMD
Defines the default command when the container starts					
---



### Virtual Machines vs Docker

A **Virtual Machine** emulates a complete computer system, including its own operating system and kernel.

**Pros:**
- Strong isolation between systems
- Suitable for running different operating systems on the same machine

**Cons:**
- High resource consumption (CPU, RAM, disk)
- Slow startup times
- Heavier maintenance and updates

Docker uses **containerization**, which isolates applications at the process level while sharing the host operating system’s kernel.

**Pros:**
- Lightweight and fast to start
- Efficient resource usage
- Easy to reproduce and deploy
- Ideal for microservices architectures

**Cons:**
- Weaker isolation compared to virtual machines
- Requires the same OS kernel as the host

| Feature         | Virtual Machines      | Docker                 |
|-----------------|-----------------------|------------------------|
| OS              | Full OS per VM        | Shared host OS         |
| Startup Time    | Slow (minutes)        | Fast (seconds)         |
| Resource Usage  | High                  | Low                    |
| Isolation Level | Very strong           | Process-level          |
| Portability     | Limited               | High                   |
| Use Case        | Full system isolation | Application deployment |


### Secrets vs Environment Variables

Secrets and environment variables are both used to manage configuration data, but they serve different purposes, especially in terms of security.

###### Secrets

Secrets are intended to store sensitive information such as database passwords, API keys, or private tokens. They are managed securely by Docker and are not hardcoded into the source code or configuration files.

**Pros:**
- Higher level of security
- Designed for sensitive credentials
- Reduced risk of accidental exposure

**Cons:**
- More complex to configure
- Requires additional setup

###### Environment Variables

Environment variables are used to configure applications dynamically without embedding values directly into the source code. In this project, environment variables are defined in a `.env` file and loaded by Docker Compose.

**Pros:**
- Simple and easy to use
- Improve flexibility and portability
- Avoid hardcoding configuration values

**Cons:**
- Less secure than secrets
- Can be exposed if the `.env` file is not protected

| Feature          | Secrets                   | Environment Variables        |
|------------------|---------------------------|------------------------------|
| Security Level   | High                      | Medium                       |
| Intended Use     | Sensitive data            | Configuration values         |
| Storage          | Managed securely by Docker | Stored in `.env` file        |
| Ease of Use      | More complex              | Simple                       |
| Use in Inception | Optional                  | Used in this project         |

 
### Docker Network vs Host Network

Docker provides different networking modes to control how containers communicate with each other and with the host system.

###### Docker Network

A Docker network allows containers to communicate with each other through an isolated virtual network managed by Docker. Each container has its own IP address and can reach other containers by service name.

**Pros:**
- Better isolation between services
- Improved security
- Controlled and predictable communication
- Recommended for multi-container applications

**Cons:**
- Slightly more configuration required
- Less direct access to the host network

###### Host Network

The host network mode removes network isolation and allows the container to share the host’s network stack directly.

**Pros:**
- Better network performance
- Direct access to host services

**Cons:**
- Reduced security
- No network isolation
- Higher risk of port conflicts

| Feature            | Docker Network           | Host Network          |
|--------------------|--------------------------|-----------------------|
| Isolation          | High                     | None                  |
| Security           | Better                   | Weaker                |
| Container Discovery| Service name resolution  | Manual                |
| Port Conflicts     | Avoided                  | Possible              |
| Use in Inception   | Used                     | Not recommended       |




### Docker Volumes vs Bind Mounts

Persistent storage is essential to ensure that data is not lost when containers are stopped or removed.

###### Docker Volumes

Docker volumes are managed entirely by Docker and stored in a dedicated area on the host filesystem. They are the recommended solution for persisting container data.

**Pros:**
- Managed by Docker
- Portable and easy to back up
- Safer and cleaner storage management

**Cons:**
- Less direct control over file location
- Slightly less transparent for beginners

###### Bind Mounts

Bind mounts map a specific directory or file from the host machine into a container.

**Pros:**
- Direct access to host files
- Useful for development environments

**Cons:**
- Less portable
- Can expose host filesystem
- More prone to permission issues

| Feature          | Docker Volumes          | Bind Mounts           |
|------------------|-------------------------|-----------------------|
| Management       | Managed by Docker       | Managed by host       |
| Portability      | High                    | Low                   |
| Security         | Better                  | Weaker                |
| Use Case         | Production data         | Development use       |
| Use in Inception | Used                    | Not recommended       |


## Instructions & Resources

### Requirements
- Docker
- Docker Compose

### Installation
Clone the repository and move into the project directory:
git clone <repository_url>
cd inception


Create and configure the environment variables:
cp .env.example .env
Edit the `.env` file and set your own credentials and configuration values.

### Build and Run
Build and start the infrastructure:
docker-compose up --build
Stop the containers:
docker-compose down
All persistent data is stored using Docker volumes, so stopping or restarting containers will **not** result in data loss.

### Resources

**Documentation**
- Docker: [https://docs.docker.com/](https://docs.docker.com/)
- Docker Compose: [https://docs.docker.com/compose/](https://docs.docker.com/compose/)
- NGINX: [https://nginx.org/en/docs/](https://nginx.org/en/docs/)
- WordPress: [https://wordpress.org/documentation/](https://wordpress.org/documentation/)
- MariaDB: [https://mariadb.com/kb/en/documentation/](https://mariadb.com/kb/en/documentation/)

**Video Tutorials**
- Docker for Beginners – Learn docker in 1hour: [https://youtu.be/GFgJkfScVNU?si=984k2PcTeiA4IcjE]
- Docker Compose Tutorial – TechWorld with Nana: [https://www.youtube.com/watch?v=zFa9_K8BS8I]

-e 


===== ./srcs/requirements/mariaDb/tools/init_db.sh =====
#!/bin/bash
set -e

# MariaDB data directory
DATADIR="/var/lib/mysql"

# Create required directories
mkdir -p /run/mysqld
mkdir -p "$DATADIR"
mkdir -p /var/log/mysql

# Fix ownerships
chown -R mysql:mysql /run/mysqld
chown -R mysql:mysql "$DATADIR"
chown -R mysql:mysql /var/log/mysql

# Initialize database only if empty
if [ ! -d "$DATADIR/mysql" ]; then
    # Initialize system tables
    mysql_install_db --user=mysql --datadir="$DATADIR"

    # Temporary start of MariaDB
    mysqld --user=mysql --datadir="$DATADIR" --skip-networking &
    pid=$!

    # Wait for MariaDB to be ready
    until mysqladmin ping --silent; do
        sleep 1
    done

    # Database and users setup
    mysql -u root <<EOF
-- Create WordPress database
CREATE DATABASE IF NOT EXISTS \`${MYSQL_DATABASE}\`
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

-- Secure root user
DROP USER IF EXISTS 'root'@'%';
CREATE USER 'root'@'%' IDENTIFIED BY '${MYSQL_ROOT_PASSWORD}';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;

-- WordPress user
DROP USER IF EXISTS '${MYSQL_USER}'@'%';
CREATE USER '${MYSQL_USER}'@'%' IDENTIFIED BY '${MYSQL_PASSWORD}';
GRANT ALL PRIVILEGES ON \`${MYSQL_DATABASE}\`.* TO '${MYSQL_USER}'@'%';

-- Optional admin user
DROP USER IF EXISTS '${MYSQL_ADMIN}'@'%';
CREATE USER '${MYSQL_ADMIN}'@'%' IDENTIFIED BY '${MYSQL_ADMIN_PASSWORD}';
GRANT ALL PRIVILEGES ON \`${MYSQL_DATABASE}\`.* TO '${MYSQL_ADMIN}'@'%';

FLUSH PRIVILEGES;
EOF

    # Stop temporary MariaDB
    mysqladmin shutdown
    wait "$pid"
fi

# Start MariaDB normally
exec mysqld --user=mysql --datadir="$DATADIR" --bind-address=0.0.0.0
-e 


===== ./srcs/requirements/mariaDb/Dockerfile =====
FROM debian:bullseye

RUN apt-get update && \
    apt-get install -y mariadb-server && \
    rm -rf /var/lib/apt/lists/*

COPY conf/50-server.conf /etc/mysql/mariadb.conf.d/50-server.cnf
COPY tools/init_db.sh /init_db.sh

RUN chmod +x /init_db.sh

ENTRYPOINT ["/init_db.sh"]
-e 


===== ./srcs/requirements/mariaDb/conf/50-server.conf =====
[mysqld]
user = mysql
datadir = /var/lib/mysql
bind-address = 0.0.0.0
port = 3306
-e 


===== ./srcs/requirements/nginx/Dockerfile =====
FROM debian:bullseye

RUN apt-get update && \
    apt-get install -y nginx openssl && \
    rm -rf /var/lib/apt/lists/*

RUN mkdir -p /etc/nginx/ssl /var/www/html

RUN openssl req -x509 -nodes \
    -out /etc/nginx/ssl/inception.crt \
    -keyout /etc/nginx/ssl/inception.key \
    -subj "/C=ES/ST=Andalucia/L=Malaga/O=42/OU=42/CN=csalamit.42.fr/UID=csalamit"

COPY conf/nginx.conf /etc/nginx/nginx.conf
COPY tools/execute.sh /execute.sh


RUN chmod +x /execute.sh

EXPOSE 443

CMD ["/execute.sh"]
-e 


===== ./srcs/requirements/nginx/conf/nginx.conf =====
events {}

http {
    server {
        listen 443 ssl;
        listen [::]:443 ssl;

        server_name csalamit.42.fr;

        ssl_certificate     /etc/nginx/ssl/inception.crt;
        ssl_certificate_key /etc/nginx/ssl/inception.key;

        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        root /var/www/html;
        index index.php index.html;

        access_log /var/log/nginx/access.log;
        error_log /var/log/nginx/error.log;

        location / {
            try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
            include fastcgi_params;
            fastcgi_pass wordpress:9000;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        }

        location ~ /\.ht {
            deny all;
        }
    }
}
-e 


===== ./srcs/requirements/nginx/tools/execute.sh =====
#!/bin/sh


nginx -g "daemon off;"
-e 


===== ./srcs/requirements/wordPress/conf/www.conf =====
-e 


===== ./srcs/requirements/wordPress/tools/setup_wordpress.sh =====
#!/bin/bash
set -e

# Chemin où WordPress doit être installé
WP_PATH="/var/www/html"

# Créer le dossier si besoin (rarement nécessaire si volume est vide)
mkdir -p "$WP_PATH"
chown -R www-data:www-data "$WP_PATH"
chmod -R 755 "$WP_PATH"

# Télécharger WordPress seulement si le dossier est vide
if [ ! -f "$WP_PATH/wp-config.php" ] && [ ! -f "$WP_PATH/index.php" ]; then
    echo "→ Téléchargement de WordPress..."
    wget -q https://wordpress.org/latest.tar.gz -O /tmp/wordpress.tar.gz
    tar -xzf /tmp/wordpress.tar.gz -C /tmp/
    cp -r /tmp/wordpress/. "$WP_PATH/"
    rm -rf /tmp/wordpress /tmp/wordpress.tar.gz
    chown -R www-data:www-data "$WP_PATH"
fi

# Attendre que MariaDB soit prêt (très important !)
echo "→ Attente de MariaDB (${MYSQL_HOST})..."
max_tries=30
counter=0
until mysqladmin ping -h "${MYSQL_HOST}" -u root -p"${MYSQL_ROOT_PASSWORD}" --silent; do
    if [ $counter -ge $max_tries ]; then
        echo "ERREUR : MariaDB n'est pas prêt après ${max_tries} tentatives"
        exit 1
    fi
    counter=$((counter+1))
    sleep 1
done
echo "→ MariaDB est prêt !"

# Installer wp-cli si pas déjà présent
if [ ! -f "/usr/local/bin/wp" ]; then
    echo "→ Installation de wp-cli..."
    curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
    chmod +x wp-cli.phar
    mv wp-cli.phar /usr/local/bin/wp
fi

cd "$WP_PATH"

# Créer wp-config.php seulement s'il n'existe pas
if [ ! -f wp-config.php ]; then
    echo "→ Création de wp-config.php..."
    wp config create \
        --dbname="${MYSQL_DATABASE}" \
        --dbuser="${MYSQL_USER}" \
        --dbpass="${MYSQL_PASSWORD}" \
        --dbhost="${MYSQL_HOST}" \
        --dbcharset="utf8mb4" \
        --dbcollate="utf8mb4_unicode_ci" \
        --allow-root \
        --skip-check
fi

# Installer WordPress seulement si pas déjà fait
if ! wp core is-installed --allow-root; then
    echo "→ Installation de WordPress..."
    wp core install \
        --url="${WP_URL}" \
        --title="${WP_TITLE}" \
        --admin_user="${WP_USER}" \
        --admin_password="${WP_USER_PASSWORD}" \
        --admin_email="${WP_USER_EMAIL}" \
        --skip-email \
        --allow-root

    # Créer un utilisateur normal (optionnel mais souvent demandé)
    wp user create \
        "${WP_USER}" \
        "${WP_USER_EMAIL}" \
        --user_pass="${WP_USER_PASSWORD}" \
        --role=author \
        --allow-root || true
fi

# Optionnel : forcer certaines options (debug, etc.)
wp option update siteurl "https://${DOMAIN_NAME}" --allow-root || true
wp option update home    "https://${DOMAIN_NAME}" --allow-root || true

if [ "${WP_DEBUG}" = "true" ]; then
    wp config set WP_DEBUG true --raw --allow-root
    wp config set WP_DEBUG_LOG true --raw --allow-root
    wp config set WP_DEBUG_DISPLAY false --raw --allow-root
fi

# Permissions finales
chown -R www-data:www-data "$WP_PATH"
find "$WP_PATH" -type d -exec chmod 755 {} \;
find "$WP_PATH" -type f -exec chmod 644 {} \;

echo "→ WordPress est prêt ! Lancement de php-fpm..."

# Lancer php-fpm en foreground (important !)
exec php-fpm8.3 -F   # ou php-fpm7.4, php-fpm8.2, php-fpm8.1 selon ta version dans le Dockerfile
# Alternative : exec php-fpm --nodaemonize-e 


===== ./srcs/requirements/wordPress/Dockerfile =====
FROM debian:bullseye

# Ajouter le dépôt Ondřej Surý (PHP récent)
RUN apt-get update && apt-get install -y \
    apt-transport-https \
    lsb-release \
    ca-certificates \
    curl \
    gnupg \
    && curl -sSLo /usr/share/keyrings/deb.sury.org-php.gpg https://packages.sury.org/php/apt.gpg \
    && echo "deb [signed-by=/usr/share/keyrings/deb.sury.org-php.gpg] https://packages.sury.org/php/ $(lsb_release -sc) main" > /etc/apt/sources.list.d/php.list \
    && apt-get update

# Installer PHP 8.3 + extensions nécessaires pour WordPress
RUN apt-get install -y \
    php8.3 \
    php8.3-fpm \
    php8.3-mysql \
    php8.3-curl \
    php8.3-gd \
    php8.3-mbstring \
    php8.3-xml \
    php8.3-zip \
    php8.3-soap \
    php8.3-intl \
    mariadb-client \
    curl \
    wget \
    && rm -rf /var/lib/apt/lists/*

# Créer le dossier pour php-fpm socket/pid
RUN mkdir -p /run/php

# Configurer php-fpm pour écouter sur port 9000 (au lieu de socket unix par défaut)
RUN sed -i 's|^listen = .*|listen = 9000|' /etc/php/8.3/fpm/pool.d/www.conf \
    && sed -i 's|^;listen.owner = .*|listen.owner = www-data|' /etc/php/8.3/fpm/pool.d/www.conf \
    && sed -i 's|^;listen.group = .*|listen.group = www-data|' /etc/php/8.3/fpm/pool.d/www.conf \
    && sed -i 's|^;listen.mode = .*|listen.mode = 0660|' /etc/php/8.3/fpm/pool.d/www.conf

# Copier et rendre exécutable le script d'init
COPY tools/setup_wordpress.sh /setup_wordpress.sh
RUN chmod +x /setup_wordpress.sh

# Utiliser ENTRYPOINT pour lancer le script au démarrage
EXPOSE 9000
ENTRYPOINT ["/setup_wordpress.sh"]-e 


===== ./srcs/.env =====
# MYSQL
MYSQL_ROOT_PASSWORD=rootpass
MYSQL_DATABASE=wordpress
MYSQL_USER=csalamit
MYSQL_PASSWORD=user
MYSQL_ADMIN=admin
MYSQL_ADMIN_PASSWORD=user
MYSQL_HOST=mariadb

# WORDPRESS
WP_TITLE="Inception csalamit"
WP_URL=https://csalamit.42.fr
WP_ADMIN_EMAIL=admin@42.fr
WP_USER=csalamit
WP_USER_PASSWORD=user
WP_USER_EMAIL=csalamit@42.fr
DOMAIN_NAME=csalamit.42.fr
WP_DEBUG=true
-e 


===== ./srcs/docker-compose.yml =====
version: '3.8'

services:
  mariadb:
    build: requirements/mariaDb
    container_name: mariadb
    restart: always
    env_file: .env
    volumes:
      - mariadb_data:/var/lib/mysql
    networks:
      - inception

  wordpress:
    build: requirements/wordPress
    container_name: wordpress
    env_file: .env
    depends_on:
      - mariadb
    volumes:
      - wordpress_data:/var/www/html
    networks:
      - inception
    restart: always

  nginx:
    build: requirements/nginx
    container_name: nginx
    depends_on:
      - wordpress
    volumes:
      - wordpress_data:/var/www/html:cached 
    ports:
      - "443:443"
    networks:
      - inception
    restart: always

volumes:
  mariadb_data:
  wordpress_data:

networks:
  inception:
-e 


===== ./DEV_DOC.md =====
# Developer documentation 

-------------



# 1-Set up the environment from scratch (prerequisites, configuration files, secrets).

### General system requirements

To install Docker Desktop successfully, your Linux host must meet the following general requirements:

64-bit kernel and CPU support for virtualization.
KVM virtualization support. Follow the KVM virtualization support instructions to check if the KVM kernel modules are enabled and how to provide access to the KVM device.
QEMU must be version 5.2 or later. We recommend upgrading to the latest version.
systemd init system.
GNOME, KDE, or MATE desktop environments are supported but others may work.
For many Linux distributions, the GNOME environment does not support tray icons. To add support for tray icons, you need to install a GNOME extension. For example, AppIndicator.
At least 4 GB of RAM.
Enable configuring ID mapping in user namespaces, see File sharing. Note that for Docker Desktop version 4.35 and later, this is not required anymore.
Recommended: Initialize pass for credentials management.


### Set up 
for the subject we need to use a VM :
open the VM , create a new Vm with your settings and the image of your choice ( I took debian)
make your basic instalation
to make things easier I create a remote vs-code using ssh ex : (ssh:localhost:2222)

install docker 
install docker compose : 
create a makefile + a docker-compose.yml
create a source file, inside create the directories you need with each of them a Dockerfile

create a file .env so you can store your password and not push them, they need to stay private


--------------------------------


# 2-Build and launch the project using the Makefile and Docker Compose.

because of the makefile then the docker-compose.yml and then the differents dockerfile
To build it you shall open the terminal and write make 


# 3-Use relevant commands to manage the containers and volumes.


check if it is on and the name of the differents informations with : 
------------------
#### docker ps
--------------------------

you will have the name of container Id, image, command , when it is created , the ports and finally the names

Build : 
------------------------------
#### docker compose build {name}
#### docker compose up -d {name}
----------------------------------

It allows you to build only one directory

test if up : 
----------------------------------
#### docker logs -f {name} (via an other terminal )
----------------------------------------



Delete container : 
------------------------------
#### docker compose down -v
-------------------------------

if you do (  docker compose down -v && \ docker compose build --no-cache mariadb && \ docker compose up mariadb
) you will delete a container and start again .
--------------------------------


Open a new terminal to connect to the data base : 
--------------------------------------------

docker exec -it mariadb mysql -u root -p or docker exec -it mariadb mysql -u wp_user -p

---------------------------

to see what happen in our container : 

#### docker logs {$IMAGE}
------------------------------

test wordpress :

### curl -k https://localhost

-------------------------------

connect in mariaDb container :

### docker exec -it mariadb bash
### mysql -u root -p
 name and rootpassword

 once you have =>    MariaDB [(none)]>

### SHOW DATABASES;



# 4-Identify where the project data is stored and how it persists.



---------------------------------------------------------------------------------------




-e 


===== ./Makefile =====
COMPOSE_FILE = srcs/docker-compose.yml

all: up

up: $(COMPOSE_FILE)
	@echo "[i] Starting Inception..."
	@sudo docker compose -f $(COMPOSE_FILE) up --build -d
	@touch up
	@echo "[i] Inception successfully up !"

down:
	@echo "[i] Stopping Inception..."
	@sudo docker compose -f $(COMPOSE_FILE) down
	@rm -f up

clean:
	@echo "[i] Cleaning Inception..."
	@sudo docker compose -f $(COMPOSE_FILE) down -v --remove-orphans
	@sudo docker system prune -f --volumes
	@rm -f up

fclean:
	@echo "[i] Force cleaning everything..."
	@docker stop $$(docker ps -qa) 2>/dev/null || true
	@docker rm $$(docker ps -qa) 2>/dev/null || true
	@docker rmi -f $$(docker images -qa) 2>/dev/null || true
	@docker volume rm $$(docker volume ls -q) 2>/dev/null || true
	@docker network rm $$(docker network ls -q) 2>/dev/null || true

re: fclean all

.PHONY: all up down clean fclean re
-e 


===== ./USER_DOC.md =====
# User documentation 


# 1-Understand what services are provided by the stack.


--------------------------------------------
# 2-Start and stop the project.


------------------------------------------------

# 3-Access the website and the administration panel.

--------------------------------------------------

# 4-Locate and manage credentials.


----------------------------------------------


# 5-Check that the services are running correctly.-e 


